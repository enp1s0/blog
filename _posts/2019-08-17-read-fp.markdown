---
layout: post
title:  "LAPACKEのlatmsを使う"
date:   2019-08-17 01:08:41 +0900
categories: etc
---

{% include header.markdown %}

<p>
浮動小数点数の16進数表記を見てどれくらいの値かを知りたくなることがありますよね．<br>
そのために知っておくと便利なことなどをまとめておこうかと思います．
</p>
<h2>浮動小数点数の基礎</h2>
<p>
学校で計算機関係の講義を取ったりIPAの試験を受けようとすると必ず出てくる話です．<br>
小数は広く使われている計算機の中では浮動小数点数という形で扱われています．<br>
浮動小数点数を構成する部分は3つあって，「符号部」「指数部」「仮数部」と日本語では呼ばれています．<br>
例えばIEEE 754 binary64，いわゆる倍精度浮動小数点数では最上位ビットから1bit，11bit，52bitの計64bitとなっています．<br>
これでどうやってある数Aを表すかというと，0以外であれば
{% highlight text %}
|A| = 0x1[仮数部] x 2^{指数部 - bias}
{% endhighlight %}
となります．<br>
符号は符号部が1なら負です．<br>
biasがあることで絶対値が1未満の数も表せるようになっています．<br>
biasは定数です．<br>
仮数部はケチ表現ですね．<br>
0以外の数の2進数の最上位ビットは必ず1になるため省略するやつです．
</p>


<h2>覚えておくといいこと</h2>
<h3>1</h3>
1は覚えておきましょう．<br>
1を覚えておくと指数部のbiasが分かります．
<table class='table'>
  <thead>
  <tr>
    <th></th>
    <th>16進数</th>
    <th>bias</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>binary64<br></td>
    <td>0x3ff0000000000000</td>
    <td>0x3fff = 1023</td>
  </tr>
  <tr>
    <td>binary32</td>
    <td>0x3f800000</td>
    <td>0x3f8 >> 3 = 0x7f = 127</td>
  </tr>
  <tr>
    <td>binary16</td>
    <td>0x3c00<br></td>
    <td>0x3c >> 2 = 0xf = 15</td>
  </tr>
  </tbody>
</table>
<p>
biasを求めるには0でない部分を切り出して最下位ビットが1になるまでシフトすればいいです．

<h3>符号部</h3>
符号部に1が立つということは最上位4bitの最上位ビットに1が立つということです．
例えばFP64では
{% highlight text %}
1 = 0x3ff0000000000000
{% endhighlight %}
が
{% highlight text %}
-1 = 0xbff0000000000000
{% endhighlight %}
となります．

<h3>常識的な最上位4bit</h3>
（少なくとも私の）常識の範囲内の数は絶対値がいたずらに大きかったり小さかったりしないため，binary64では0x3,0x4,0xb,0xcから始まる数の羅列を見たらいい感じの浮動小数点数列だーなんて思うわけです．

<h3>扱っいる数の大体の範囲の端</h3>
扱っている数の絶対値が1/32 ~ 32 に多いのであれば，例えばbinary64では
{% highlight text %}
1/32 = 0x3fa0000000000000
  32 = 0x4040000000000000
{% endhighlight %}
を覚えておくと読みたい数の大きさをやんわりと捉えられるかもしれないです．

<h2>おわりに</h2>
<p>
現在目で16進数表記の浮動小数点数を読む修行中なのでこれくらいしかかけませんが，他に有用な情報があれば是非教えていただけたらと思います．<br>
なんか，逆に16進表記もできるようになってきた気がします... .
</p>
